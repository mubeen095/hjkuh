{"id":2686,"date":"2024-05-10T11:20:36","date_gmt":"2024-05-10T11:20:36","guid":{"rendered":"https:\/\/www.skillvertex.com\/blog\/?p=2686"},"modified":"2024-05-10T11:20:36","modified_gmt":"2024-05-10T11:20:36","slug":"function-pointer-in-c","status":"publish","type":"post","link":"https:\/\/www.skillvertex.com\/blog\/function-pointer-in-c\/","title":{"rendered":"Function Pointer In C"},"content":{"rendered":"\n<div class=\"wp-block-rank-math-toc-block\" id=\"rank-math-toc\" id=\"rank-math-toc\"><p>Table of Contents<\/p><nav><ul><li ><a href=\"#function-pointer-in-c\">Function Pointer In C<\/a><\/li><li ><a href=\"#interesting-facts-about-function-pointers\">Interesting facts about function pointers<\/a><\/li><li ><a href=\"#faq-function-pointer-in-c\">FAQ- Function Pointer In C?<\/a><\/li><\/ul><\/nav><\/div>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"function-pointer-in-c\">Function Pointer In C<\/h2>\n\n\n\n<p>Function pointers are a powerful feature of the C language that allows you to store and call functions through pointers.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>#include &lt;stdio.h&gt; \n\/\/ A normal function with an int parameter \n\/\/ and void return type \nvoid fun(int a) \n{ \n    printf(\"Value of a is %d\\n\", a); \n} \n  \nint main() \n{ \n    \/\/ fun_ptr is a pointer to function fun()  \n    void (*fun_ptr)(int) = &amp;fun; \n  \n    \/* The above line is equivalent of following two \n       void (*fun_ptr)(int); \n       fun_ptr = &amp;fun;  \n    *\/\n  \n    \/\/ Invoking fun() using fun_ptr \n    (*fun_ptr)(10); \n  \n    return 0; \n} <\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>Value of a is 10\n<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"interesting-facts-about-function-pointers\">Interesting facts about function pointers<\/h2>\n\n\n\n<ol class=\"wp-block-list\">\n<li>Function pointers in C do indeed point to code, not data. They store the memory address of the executable code of a function, allowing you to call that function dynamically at runtime. This is a fundamental distinction between function pointers and regular data pointers, which point to data in memory. Function pointers are a powerful feature in C that enables dynamic and flexible function invocation<\/li>\n<\/ol>\n\n\n\n<ol class=\"wp-block-list\" start=\"2\">\n<li>Function pointers are used to reference and call functions, not to allocate or deallocate memory. Memory allocation and deallocation are typically performed using data pointers, such as those returned by functions like <code>malloc<\/code> and <code>free<\/code>.<\/li>\n\n\n\n<li>In C, you can obtain a function&#8217;s address by simply using the function&#8217;s name without the address operator <code>&amp;<\/code>. This is because the name of a function, when used in an expression (without parentheses), automatically converts to a function pointer. So, you can call a function using the function&#8217;s name without needing to use the dereference operator <code>*<\/code>.<\/li>\n<\/ol>\n\n\n\n<pre class=\"wp-block-code\"><code>\n#include &lt;stdio.h&gt; \n\/\/ A normal function with an int parameter \n\/\/ and void return type \nvoid fun(int a) \n{ \n    printf(\"Value of a is %d\\n\", a); \n} \n  \nint main() \n{  \n    void (*fun_ptr)(int) = fun;  \/\/ &amp; removed \n  \n    fun_ptr(10);  \/\/ * removed \n  \n    return 0; \n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>Value of a is 10<\/code><\/pre>\n\n\n\n<p>4. Function pointers can indeed be used to create an array of pointers to functions, which allows for dynamic function dispatch, similar to a switch-case statement. This can lead to more flexible and maintainable code, as you can choose which function to execute at runtime based on user choices or other conditions.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>#include &lt;stdio.h&gt; \nvoid add(int a, int b) \n{ \n    printf(\"Addition is %d\\n\", a+b); \n} \nvoid subtract(int a, int b) \n{ \n    printf(\"Subtraction is %d\\n\", a-b); \n} \nvoid multiply(int a, int b) \n{ \n    printf(\"Multiplication is %d\\n\", a*b); \n} \n  \nint main() \n{ \n    \/\/ fun_ptr_arr is an array of function pointers \n    void (*fun_ptr_arr&#91;])(int, int) = {add, subtract, multiply}; \n    unsigned int ch, a = 15, b = 10; \n  printf(\"Enter Choice: 0 for add, 1 for subtract and 2 \"\n            \"for multiply\\n\"); \n    scanf(\"%d\", &amp;ch); \n  \n    if (ch &gt; 2) return 0; \n  \n    (*fun_ptr_arr&#91;ch])(a, b); \n  \n    return 0; \n} <\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>Enter Choice: 0 for add, 1 for subtract and 2 for multiply\n2\nMultiplication is 150 <\/code><\/pre>\n\n\n\n<p>5. Function pointers can be passed as arguments to functions and can also be returned from functions in C. This feature enables dynamic behavior and allows you to create functions that can work with different functions based on the context.<\/p>\n\n\n\n<p>For example, consider the following C program where wrapper() receives a void fun() as parameter and calls the passed function.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\n\n\/\/ A simple C program to show function pointers as parameter \n#include &lt;stdio.h&gt; \n  \n\/\/ Two simple functions \nvoid fun1() { printf(\"Fun1\\n\"); } \nvoid fun2() { printf(\"Fun2\\n\"); } \n  \n\/\/ A function that receives a simple function \n\/\/ as parameter and calls the function \nvoid wrapper(void (*fun)()) \n{ \n    fun(); \n} \n  \nint main() \n{ \n    wrapper(fun1); \n    wrapper(fun2); \n    return 0; \n}<\/code><\/pre>\n\n\n\n<p>6. Using function pointers is a powerful technique in C to reduce code redundancy and create more flexible, reusable code. Your example with <code>qsort()<\/code> is a perfect illustration of this.<\/p>\n\n\n\n<p>In the <code>qsort()<\/code> function from the C Standard Library, you can specify a comparison function through a function pointer. This allows you to sort arrays in different orders or based on different criteria without modifying the sorting algorithm itself.<\/p>\n\n\n\n<p>The flexibility of function pointers and void pointers enables <code>qsort()<\/code> to be used with arrays of any data type, making it a generic sorting solution. This kind of abstraction and reusability is one of the strengths of the C language, particularly when working with data structures and algorithms.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/\/ An example for qsort and comparator \n#include &lt;stdio.h&gt; \n#include &lt;stdlib.h&gt; \n  \n\/\/ A sample comparator function that is used \n\/\/ for sorting an integer array in ascending order. \n\/\/ To sort any array for any other data type and\/or \n\/\/ criteria, all we need to do is write more compare \n\/\/ functions.  And we can use the same qsort() \nint compare (const void * a, const void * b) \n{ \n  return ( *(int*)a - *(int*)b ); \n} \n  \nint main () \n{ \n  int arr&#91;] = {10, 5, 15, 12, 90, 80}; \n  int n = sizeof(arr)\/sizeof(arr&#91;0]), i; \n  \n  qsort (arr, n, sizeof(int), compare); \n  \n  for (i=0; i&lt;n; i++) \n     printf (\"%d \", arr&#91;i]); \n  return 0; \n} <\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>5 10 12 15 80 90\n<\/code><\/pre>\n\n\n\n<p>Writing generic functions with function pointers is a powerful way to create reusable and versatile code. Your example of a search function that can be used for any data type and customized for specific tasks by providing a comparison function is a great illustration of this concept.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>#include &lt;stdio.h&gt; \n#include &lt;stdbool.h&gt; \n  \n\/\/ A compare function that is used for searching an integer \n\/\/ array \nbool compare (const void * a, const void * b) \n{ \n  return ( *(int*)a == *(int*)b ); \n} \n  \n\/\/ General purpose search() function that can be used \n\/\/ for searching an element *x in an array arr&#91;] of \n\/\/ arr_size. Note that void pointers are used so that \n\/\/ the function can be called by passing a pointer of \n\/\/ any type.  ele_size is size of an array element \nint search(void *arr, int arr_size, int ele_size, void *x, \n           bool compare (const void * , const void *)) \n{ \n    \/\/ Since char takes one byte, we can use char pointer \n    \/\/ for any type\/ To get pointer arithmetic correct, \n    \/\/ we need to multiply index with size of an array \nchar *ptr = (char *)arr; \n  \n    int i; \n    for (i=0; i&lt;arr_size; i++) \n        if (compare(ptr + i*ele_size, x)) \n           return i; \n  \n    \/\/ If element not found \n    return -1; \n} \n  \nint main() \n{ \n    int arr&#91;] = {2, 5, 7, 90, 70}; \n    int n = sizeof(arr)\/sizeof(arr&#91;0]); \n    int x = 7; \n    printf (\"Returned index is %d \", search(arr, n, \n                               sizeof(int), &amp;x, compare)); \n    return 0; \n} <\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>Returned index is 2\n<\/code><\/pre>\n\n\n\n<p>7.<strong>Virtual Functions:<\/strong> In C++, virtual functions enable polymorphism, allowing derived classes to provide their implementations. This behavior is achieved using function pointers in the background, as the correct function to call at runtime is determined based on the object&#8217;s actual type.<\/p>\n\n\n\n<p>8. <strong>Class Methods (Member Function Pointers):<\/strong> Class methods in C++ are implemented using member function pointers. These pointers point to member functions within a class. Member function pointers are essential for features like callback functions and dynamic function dispatch within classes.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"faq-function-pointer-in-c\">FAQ- Function Pointer In C?<\/h2>\n\n\n<div id=\"rank-math-faq\" class=\"rank-math-block\">\n<div class=\"rank-math-list \">\n<div id=\"faq-question-1697198902293\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q1. What is a function pointer with an example?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. In this example, <code>FP<\/code> is a pointer that points to a function accepting a float argument and returning a float value. The syntax for declaring a function pointer is similar to that of a function declaration, with the addition of <code>*<\/code> to indicate it&#8217;s a pointer.<\/p>\n\n<\/div>\n<\/div>\n<div id=\"faq-question-1697198909326\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q2. What is the size of function pointer?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. In C, pointers store the addresses of variables. The size of a pointer depends on the computer&#8217;s word size, typically 4 bytes on 32-bit systems and 8 bytes on 64-bit systems.<\/p>\n\n<\/div>\n<\/div>\n<div id=\"faq-question-1697198919059\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q3. What is the syntax of function pointer?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. <strong>void (*foo)( int );<\/strong> is the syntax of function pointer<\/p>\n\n<\/div>\n<\/div>\n<\/div>\n<\/div>","protected":false},"excerpt":{"rendered":"<p>Function Pointer In C Function pointers are a powerful feature of the C language that allows you to store and call functions through pointers. Output Interesting facts about function pointers Output 4. Function pointers can indeed be used to create an array of pointers to functions, which allows for dynamic function dispatch, similar to a &#8230; <a title=\"Function Pointer In C\" class=\"read-more\" href=\"https:\/\/www.skillvertex.com\/blog\/function-pointer-in-c\/\" aria-label=\"More on Function Pointer In C\">Read more<\/a><\/p>\n","protected":false},"author":4,"featured_media":5371,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[27],"tags":[459],"class_list":["post-2686","post","type-post","status-publish","format-standard","has-post-thumbnail","hentry","category-c-programming","tag-function-pointer-in-c","generate-columns","tablet-grid-50","mobile-grid-100","grid-parent","grid-33"],"_links":{"self":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/2686"}],"collection":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/comments?post=2686"}],"version-history":[{"count":10,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/2686\/revisions"}],"predecessor-version":[{"id":10724,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/2686\/revisions\/10724"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/media\/5371"}],"wp:attachment":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/media?parent=2686"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/categories?post=2686"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/tags?post=2686"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}