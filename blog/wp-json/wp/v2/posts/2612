{"id":2612,"date":"2024-05-10T11:02:51","date_gmt":"2024-05-10T11:02:51","guid":{"rendered":"https:\/\/www.skillvertex.com\/blog\/?p=2612"},"modified":"2024-05-10T11:05:05","modified_gmt":"2024-05-10T11:05:05","slug":"arrays-are-passed-to-functions-in-c-c","status":"publish","type":"post","link":"https:\/\/www.skillvertex.com\/blog\/arrays-are-passed-to-functions-in-c-c\/","title":{"rendered":"How Arrays Are Passed To Functions In C\/C++?"},"content":{"rendered":"\n<div class=\"wp-block-rank-math-toc-block\" id=\"rank-math-toc\" id=\"rank-math-toc\"><p>Table of Contents<\/p><nav><ul><li ><a href=\"#how-arrays-are-passed-to-functions-in-c-c\">How Arrays Are Passed To Functions In C\/C++?<\/a><\/li><li ><a href=\"#how-arrays-are-passed-in-c\">How Arrays Are Passed in C <\/a><\/li><li ><a href=\"#calculating-the-output-of-given-c-programs\">Calculating the output of given C programs<\/a><\/li><li ><a href=\"#program-1\">Program 1<\/a><\/li><li ><a href=\"#program-2\">Program 2<\/a><\/li><li ><a href=\"#program-3\">Program 3<\/a><\/li><li ><a href=\"#program-4\">Program 4<\/a><\/li><li ><a href=\"#template-approach-reference-to-array\">Template Approach (Reference to Array):<\/a><\/li><li ><a href=\"#faq-how-arrays-are-passed-to-functions-in-c-c\">FAQ- How Arrays Are Passed To Functions In C\/C++?<\/a><\/li><\/ul><\/nav><\/div>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"how-arrays-are-passed-to-functions-in-c-c\">How Arrays Are Passed To Functions In C\/C++?<\/h2>\n\n\n\n<p>In C++, you cannot pass a whole array as an argument to a function. However, you can pass a pointer to an array by specifying the array&#8217;s name. This allows the function to work with the array&#8217;s data without making a full copy of it.<\/p>\n\n\n\n<p>In C, when you pass an array to a function, it&#8217;s always treated as a pointer to its first element. This behavior is known as &#8220;array decay,&#8221; and it means that the function receives a pointer to the array&#8217;s data rather than a copy of the entire array. Understanding this concept is important when working with arrays in function arguments in C and C++<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\n\n\/\/ CPP Program to demonstrate passing\n\/\/ an array to a function is always treated\n\/\/ as a pointer\n#include &lt;iostream&gt;\nusing namespace std;\n \n\/\/ Note that arr&#91;] for fun is \n\/\/ just a pointer even if square\n\/\/ brackets are used\nvoid fun(int arr&#91;]) \/\/ SAME AS void fun(int *arr)\n{\n    unsigned int n = sizeof(arr) \/ sizeof(arr&#91;0]);\n    cout &lt;&lt; \"\\nArray size inside fun() is \" &lt;&lt; n;\n}\n \n\/\/ Driver Code\nint main()\n{\n    int arr&#91;] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n    unsigned int n = sizeof(arr) \/ sizeof(arr&#91;0]);\n    cout &lt;&lt; \"Array size inside main() is \" &lt;&lt; n;\n    fun(arr);\n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>Array size inside main() is 8\nArray size inside fun() is 2<\/code><\/pre>\n\n\n\n<p>However, we have to pass the size of the array by considering it as a parameter. Indeed, Size won&#8217;t be required except in the case of \u2018\\0\u2019 terminated character arrays. In such cases, Size can be evaluated by checking the end of the string character.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"how-arrays-are-passed-in-c\">How Arrays Are Passed in C <\/h2>\n\n\n\n<pre class=\"wp-block-code\"><code>\n#include &lt;iostream&gt;\nusing namespace std;\n \nvoid fun(int *arr, unsigned int n)\n{\n   int i;\n   for (i = 0; i &lt; n; i++)\n     cout &lt;&lt;\" \"&lt;&lt; arr&#91;i];\n}\n \n\/\/ Driver program\nint main()\n{\n   int arr&#91;] = {1, 2, 3, 4, 5, 6, 7, 8};\n   unsigned int n = sizeof(arr)\/sizeof(arr&#91;0]);\n   fun(arr, n);\n   return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code> 1 2 3 4 5 6 7 8\n<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"calculating-the-output-of-given-c-programs\">Calculating the output of given C programs<\/h2>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"program-1\">Program 1<\/h2>\n\n\n\n<pre class=\"wp-block-code\"><code>\n\/\/ Program 1\n#include &lt;iostream&gt;\nusing namespace std;\nvoid fun(int arr&#91;], unsigned int n)\n{\n    int i;\n    for (i = 0; i &lt; n; i++)\n        cout &lt;&lt; arr&#91;i] &lt;&lt; \" \";\n}\n \n\/\/ Driver program\nint main()\n{\n    int arr&#91;] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n    unsigned int n = sizeof(arr) \/ sizeof(arr&#91;0]);\n    fun(arr, n);\n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>1 2 3 4 5 6 7 8 \n<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"program-2\">Program 2<\/h2>\n\n\n\n<pre class=\"wp-block-code\"><code>\n\/\/ Program 2\n#include &lt;iostream&gt;\nusing namespace std;\nvoid fun(int* arr)\n{\n    int i;\n \/\/Consider the size of pointer as 8 bytes\n    unsigned int n = sizeof(arr) \/ sizeof(arr&#91;0]); \n    for (i = 0; i &lt; n; i++)\n        cout &lt;&lt; \" \" &lt;&lt; arr&#91;i];\n}\n \n\/\/ Driver program\nint main()\n{\n    int arr&#91;] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n    fun(arr);\n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>1  2<\/code><\/pre>\n\n\n\n<p> In this example, the size of a pointer can vary depending on the architecture of the computer. Specifically, on a 32-bit computer, pointers are often 4 bytes in size.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"program-3\">Program 3<\/h2>\n\n\n\n<pre class=\"wp-block-code\"><code>\/\/ Program 3\n#include &lt;iostream&gt;\n#include &lt;string.h&gt;\nusing namespace std;\nvoid fun(char* arr)\n{\n    int i;\n    unsigned int n = strlen(arr);\n    cout &lt;&lt; \"n = \" &lt;&lt; n &lt;&lt; endl;\n    for (i = 0; i &lt; n; i++)\n        cout &lt;&lt; arr&#91;i] &lt;&lt; \" \";\n}\n \n\/\/ Driver program\nint main()\n{\n    char arr&#91;] = \"skillvertexquiz\";\n    fun(arr);\n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>n = 9\nskill vertexq u i z <\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"program-4\">Program 4<\/h2>\n\n\n\n<pre class=\"wp-block-code\"><code>\/\/ Program 4\n#include &lt;bits\/stdc++.h&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n \nvoid fun(char* arr)\n{\n    int i;\n    unsigned int n = strlen(arr);\n    cout &lt;&lt; \"n = \" &lt;&lt; n &lt;&lt; \"\\n\";\n    for (i = 0; i &lt; n; i++)\n        cout &lt;&lt; \" \" &lt;&lt; arr&#91;i];\n}\n \n\/\/ Driver program\nint main()\n{\n    char arr&#91;]\n        = { 's', 'k', 'i', 'l', 'l', 'q', 'u', 'i', 'z' };\n    fun(arr);\n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>n = 9\n s k i l l q u i z<\/code><\/pre>\n\n\n\n<p>One of the drawbacks of passing arrays as pointers to functions is that the compiler doesn&#8217;t have information about the array&#8217;s size or structure. From the compiler&#8217;s perspective, it sees a pointer to an element but doesn&#8217;t know the size or shape of the array. This limitation can lead to issues such as not being able to use standard library functions like <code>begin<\/code> and <code>end<\/code> on the array because there&#8217;s no built-in understanding of the array&#8217;s structure.<\/p>\n\n\n\n<p>When you pass an array as a pointer, you lose some of the built-in safety and convenience features that come with standard container types, like vectors in C++. This can make it more error-prone and less intuitive to work with arrays in certain cases.<\/p>\n\n\n\n<p>To address these issues, you can use other approaches like passing the size of the array along with the pointer or using standard library containers when possible, such as <code>std::vector<\/code> in C++, which provides more safety and convenience in handling dynamic arrays.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"template-approach-reference-to-array\">Template Approach (Reference to Array):<\/h2>\n\n\n\n<ul class=\"wp-block-list\">\n<li>This method is based on passing a reference to an array, which allows retaining information about the array&#8217;s size and structure.<\/li>\n\n\n\n<li>The use of templates, specifically template argument deduction, optimizes this method. Templates enable the automatic calculation of the length of the array at the time of function call, making it possible to create a reference to the array. This is important because a reference to an array must know the size of the array it refers to.<\/li>\n<\/ul>\n\n\n\n<p>In C++, templates are a powerful feature that allows you to write generic and type-safe code. By using templates in this context, you can create functions that work with arrays of various sizes and types, providing more flexibility and safety in your code.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\n\n\/\/ CPP Program to demonstrate template approach\n#include &lt;iostream&gt;\nusing namespace std;\n \ntemplate &lt;size_t N&gt; void print(int (&amp;a)&#91;N])\n{\n    for (int e : a) {\n        cout &lt;&lt; e &lt;&lt; endl;\n    }\n}\n \n\/\/ Driver Code\nint main()\n{\n    int a&#91;]{ 1, 2, 3, 4, 5 };\n    print(a);\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>1\n2\n3\n4\n5<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"faq-how-arrays-are-passed-to-functions-in-c-c\">FAQ- How Arrays Are Passed To Functions In C\/C++?<\/h2>\n\n\n<div id=\"rank-math-faq\" class=\"rank-math-block\">\n<div class=\"rank-math-list \">\n<div id=\"faq-question-1696941456582\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q1. Can arrays be passed to functions by value in C++?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. You can&#8217;t pass an array by value in C\/C++ because there&#8217;s no built-in way to track the array&#8217;s size. Unlike classes with constructors, arrays lack this information, making it impossible for a function to know how much memory to allocate or what to copy.<\/p>\n\n<\/div>\n<\/div>\n<div id=\"faq-question-1696941464155\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q2. How to pass an array to a function in C with example?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. 1.#include&lt;stdio.h><br \/>2. int minarray(int arr[],int size){<br \/>3.int min=arr[0];<br \/>4.int i=0;<br \/>5.for(i=1;i&lt;size;i++){<br \/>6. if(min>arr[i]){<br \/>7.min=arr[i];<br \/>}<\/p>\n\n<\/div>\n<\/div>\n<div id=\"faq-question-1696941471322\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q3. How are array variables passed to functions in C?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. To pass an array to C functions, you supply a reference to the array&#8217;s base address. This allows the function to work with the array&#8217;s data using a pointer. Multidimensional arrays can also be passed to C methods using pointers. This concept holds for arrays with multiple dimensions, such as 2D or 3D arrays. The pointers provide access to the array elements in a structured manner, allowing functions to manipulate the data effectively.<\/p>\n\n<\/div>\n<\/div>\n<\/div>\n<\/div>","protected":false},"excerpt":{"rendered":"<p>How Arrays Are Passed To Functions In C\/C++? In C++, you cannot pass a whole array as an argument to a function. However, you can pass a pointer to an array by specifying the array&#8217;s name. This allows the function to work with the array&#8217;s data without making a full copy of it. In C, &#8230; <a title=\"How Arrays Are Passed To Functions In C\/C++?\" class=\"read-more\" href=\"https:\/\/www.skillvertex.com\/blog\/arrays-are-passed-to-functions-in-c-c\/\" aria-label=\"More on How Arrays Are Passed To Functions In C\/C++?\">Read more<\/a><\/p>\n","protected":false},"author":4,"featured_media":2613,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[27],"tags":[440],"class_list":["post-2612","post","type-post","status-publish","format-standard","has-post-thumbnail","hentry","category-c-programming","tag-how-arrays-are-passed-to-functions-in-c-c","generate-columns","tablet-grid-50","mobile-grid-100","grid-parent","grid-33"],"_links":{"self":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/2612"}],"collection":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/comments?post=2612"}],"version-history":[{"count":8,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/2612\/revisions"}],"predecessor-version":[{"id":10714,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/2612\/revisions\/10714"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/media\/2613"}],"wp:attachment":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/media?parent=2612"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/categories?post=2612"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/tags?post=2612"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}