{"id":3291,"date":"2024-03-05T12:48:56","date_gmt":"2024-03-05T12:48:56","guid":{"rendered":"https:\/\/www.skillvertex.com\/blog\/?p=3291"},"modified":"2024-03-05T12:48:56","modified_gmt":"2024-03-05T12:48:56","slug":"interesting-facts-about-macros-and-preprocessors-in-c","status":"publish","type":"post","link":"https:\/\/www.skillvertex.com\/blog\/interesting-facts-about-macros-and-preprocessors-in-c\/","title":{"rendered":"Interesting Facts About Macros And Preprocessors In C"},"content":{"rendered":"\n<div class=\"wp-block-rank-math-toc-block\" id=\"rank-math-toc\" id=\"rank-math-toc\"><p>Table of Contents<\/p><nav><ul><li ><a href=\"#interesting-facts-about-macros-and-preprocessors-in-c\">Interesting Facts About Macros And Preprocessors In C<\/a><\/li><li ><a href=\"#example-to-illustrate-that-max-is-defined-as-100\">Example-to illustrate that max is defined as 100<\/a><\/li><li ><a href=\"#faq-interesting-facts-about-macros-and-preprocessors-in-c\">FAQ- Interesting Facts about Macros and Preprocessors in C<\/a><\/li><\/ul><\/nav><\/div>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"interesting-facts-about-macros-and-preprocessors-in-c\">Interesting Facts About Macros And Preprocessors In C<\/h2>\n\n\n\n<p>In C programming, lines that start with # are instructions for a special program called the preprocessor, which is called by the compiler. The preprocessor works before your program actually runs, during the compilation process.<\/p>\n\n\n\n<p>Here are some interesting things about the C preprocessor:<\/p>\n\n\n\n<p>1) When you use &#8220;#include,&#8221; it&#8217;s like taking the content of another file and putting it into your program. Think of it like copying and pasting. You can tell the preprocessor to look for that file in a standard place (using &lt; and &gt;) or in your current folder (using double quotes).<\/p>\n\n\n\n<p>2) When you use &#8220;#define&#8221; to create a constant, the preprocessor replaces that constant with a specific value wherever you use it in your program. For example, if you define &#8220;max&#8221; as 100, every time you use &#8220;max&#8221; in your code, it&#8217;s replaced with 100. This makes your code easier to read and understand.<\/p>\n\n\n\n<p>In a nutshell, the preprocessor is like a helper that simplifies your code and makes it easier for the computer to understand before your program runs.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"example-to-illustrate-that-max-is-defined-as-100\">Example-to illustrate that max is defined as 100<\/h2>\n\n\n\n<pre class=\"wp-block-code\"><code>\n\n#include &lt;stdio.h&gt;\n#define max 100\nint main()\n{\n    printf(\"max is %d\", max);\n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>max is 100<\/code><\/pre>\n\n\n\n<p>3)Macros in C can indeed take function-like arguments, and they don&#8217;t perform data type checking. This means you can use macros like the one you mentioned, &#8220;INCREMENT,&#8221; for variables of any data type. The macro doesn&#8217;t care about the data type of the argument; it simply performs text substitution.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>#include &lt;stdio.h&gt;\n#define INCREMENT(x) ++x\nint main()\n{\n    char* ptr = \"Skill Vertex \";\n    int x = 10;\n    printf(\"%s  \", INCREMENT(ptr));\n    printf(\"%d\", INCREMENT(x));\n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>kill Vertex  11<\/code><\/pre>\n\n\n\n<p>4) Macro arguments are not analyzed before macro expansion. Refer to the program given below<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>#include &lt;stdio.h&gt;\n#define MULTIPLY(a, b) a* b\nint main()\n{\n    \/\/ The macro is expanded as 2 + 3 * 3 + 5, not as 5*8\n    printf(\"%d\", MULTIPLY(2 + 3, 3 + 5));\n    return 0;\n}\n\/\/ Output: 16<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>16<\/code><\/pre>\n\n\n\n<p><strong>Another way to solve this program<\/strong> :<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>#include &lt;stdio.h&gt;\n\/\/ here, instead of writing a*a we write (a)*(b)\n#define MULTIPLY(a, b) (a) * (b)\nint main()\n{\n    \/\/ The macro is expanded as (2 + 3) * (3 + 5), as 5*8\n    printf(\"%d\", MULTIPLY(2 + 3, 3 + 5));\n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>40<\/code><\/pre>\n\n\n\n<p>5) The tokens that are passed to macros will be linked with the help of operator # # which is referred to as a Token-Pasting operator.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>#include &lt;stdio.h&gt;\n#define merge(a, b) a##b\nint main() { printf(\"%d \", merge(12, 34)); }<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>1234<\/code><\/pre>\n\n\n\n<p>6) The token that is passed to macro will be transferred to a string literal with the # before it.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\n\n#include &lt;stdio.h&gt;\n#define get(a) #a\nint main()\n{\n    \/\/ Skillvertex is changed to \"Skillvertex \"\n    printf(\"%s\", get(Skillvertex));\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>Skillvertex<\/code><\/pre>\n\n\n\n<p>7) The Macros will be noted in multiple lines with the &#8216;\\&#8217;. However, the last line doesn&#8217;t require &#8216;\\&#8217;<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\n\n#include &lt;stdio.h&gt;\n#define PRINT(i, limit)                                    \\\n    while (i &lt; limit) {                                    \\\n        printf(\"Skillvertex \");                              \\\n        i++;                                               \\\n    }\nint main()\n{\n    int i = 0;\n    PRINT(i, 3);\n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>Skillvertex  Skillvertex  Skillvertex<\/code><\/pre>\n\n\n\n<p>8) We have to ignore the macros with the arguments as it can create problems sometimes. Therefore, Inline functions should be considered due to the type-checking parameter evaluation in inline functions. Thus, From&nbsp;C99&nbsp;onward, inline functions are supported by C language.&nbsp;<\/p>\n\n\n\n<p>Refer to the program given below. We can understand that the possible output will be 1, however, it shows 36 as the output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>#include &lt;stdio.h&gt;\n \n#define square(x) x* x\nint main()\n{\n    \/\/ Expanded as 36\/6*6\n    int x = 36 \/ square(6);\n    printf(\"%d\", x);\n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>36<\/code><\/pre>\n\n\n\n<p>Another way to get the expected output as 1 is given below:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>#include &lt;stdio.h&gt;\n \n#define square(x) (x * x)\nint main()\n{\n    \/\/ Expanded as 36\/(6*6)\n    int x = 36 \/ square(6);\n    printf(\"%d\", x);\n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>1<\/code><\/pre>\n\n\n\n<p>Thus, we can conclude that inline functions can be used in the above program to get the desired result.  Refer to the program given below how to use inline functions.  Also, the program which is provided in point 4 can be corrected using the inline functions.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>#include &lt;stdio.h&gt;\n \nstatic inline int square(int x) { return x * x; }\nint main()\n{\n    int x = 36 \/ square(6);\n    printf(\"%d\", x);\n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>1<\/code><\/pre>\n\n\n\n<p>9) Preprocessors in C and C++ support conditional compilation using <code>#if<\/code>, <code>#ifdef<\/code>, <code>#ifndef<\/code>, <code>#elif<\/code>, and <code>#else<\/code> directives. These directives are used to conditionally include or exclude portions of code from the compilation process based on specified conditions.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>int main()\n{\n#if VERBOSE &gt;= 2\n    printf(\"Trace Message\");\n#endif\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>No Output<\/code><\/pre>\n\n\n\n<p>10) In C and C++ programming, it&#8217;s common for header files to be included multiple times, either directly or indirectly through other header files. This can lead to issues like redeclaration of the same variables or functions, which can cause compilation errors.<\/p>\n\n\n\n<p>To address this problem, preprocessor directives like <code>#define<\/code>, <code>#ifdef<\/code>, and <code>#ifndef<\/code> are often used in header files. Here&#8217;s how they are typically employed<\/p>\n\n\n\n<p>11) Standard macros functions to print program file ( __FILE), Date of compilation (__DATE__), Time of Compilation (__TIME__) and Line Number in C Code  (__LINE__)<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>#include &lt;stdio.h&gt;\n \nint main()\n{\n    printf(\"Current File :%s\\n\", __FILE__);\n    printf(\"Current Date :%s\\n\", __DATE__);\n    printf(\"Current Time :%s\\n\", __TIME__);\n    printf(\"Line Number :%d\\n\", __LINE__);\n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>Current File :\/usr\/share\/IDE_PROGRAMS\/C\/other\/081c548d50135ed88cfa0296159b05ca\/081c548d50135ed88cfa0296159b05ca.c\nCurrent Date :Sep  4 2019\nCurrent Time :10:17:43\nLine Number :8<\/code><\/pre>\n\n\n\n<p>12) Defined Macros can be removed using the #undef MACRO_NAME<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>#include &lt;stdio.h&gt;\n#define LIMIT 100\nint main()\n{\n    printf(\"%d\", LIMIT);\n\/\/ removing defined macro LIMIT\n#undef LIMIT\n    \/\/ Next line causes error as LIMIT is not defined\n    printf(\"%d\", LIMIT);\n    return 0;\n}<\/code><\/pre>\n\n\n\n<p><strong>In the program given below, limit as an integer variable is declared after removing previously defined macro LIMIT<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>#include &lt;stdio.h&gt;\n#define LIMIT 1000\nint main()\n{\n    printf(\"%d\", LIMIT);\n\/\/ removing defined macro LIMIT\n#undef LIMIT\n    \/\/ Declare LIMIT as integer again\n    int LIMIT = 1001;\n    printf(\"\\n%d\", LIMIT);\n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>1000\n1001<\/code><\/pre>\n\n\n\n<p>Interesting fact about macro using (#undef) is described using the program given below:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>#include &lt;stdio.h&gt;\n\/\/ div function prototype\nfloat div(float, float);\n#define div(x, y) x \/ y\n \nint main()\n{\n    \/\/ use of macro div\n    \/\/ Note: %0.2f for taking two decimal value after point\n    printf(\"%0.2f\", div(10.0, 5.0));\n\/\/ removing defined macro div\n#undef div\n    \/\/ function div is called as macro definition is removed\n    printf(\"\\n%0.2f\", div(10.0, 5.0));\n    return 0;\n}\n \n\/\/ div function definition\nfloat div(float x, float y) { return y \/ x; }<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>2.00\n0.50<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"faq-interesting-facts-about-macros-and-preprocessors-in-c\">FAQ- Interesting Facts about Macros and Preprocessors in C<\/h2>\n\n\n<div id=\"rank-math-faq\" class=\"rank-math-block\">\n<div class=\"rank-math-list \">\n<div id=\"faq-question-1699348433435\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q1. What is the purpose C preprocessor macros?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. The C preprocessor is a tool that transforms your code before compilation. It handles tasks like including header files, expanding macros, and performing conditional compilation. It makes your code more readable and prepares it for the compiler.<\/p>\n\n<\/div>\n<\/div>\n<div id=\"faq-question-1699348442442\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q2. Which is faster preprocessor or macro?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. When it comes to macros in C\/C++, one of the main advantages is speed \u2013 they lead to faster execution. Macros are expanded (replaced with their definitions) directly in the code each time they are used. In contrast, a function definition is processed only once, no matter how many times it&#8217;s called. This speed advantage makes macros suitable for certain performance-critical scenarios.<\/p>\n\n<\/div>\n<\/div>\n<div id=\"faq-question-1699348455178\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q3. Can we change macro value in C?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. In C, when you define a macro, it stays effective in your program from the moment you define it until you change it, remove it, or finish compiling your program. So, if you change the value of a macro, that new value will be used throughout your program unless you change it again or until you finish writing your code. This can be handy for controlling how certain parts of your program work.<\/p>\n\n<\/div>\n<\/div>\n<\/div>\n<\/div>","protected":false},"excerpt":{"rendered":"<p>Interesting Facts About Macros And Preprocessors In C In C programming, lines that start with # are instructions for a special program called the preprocessor, which is called by the compiler. The preprocessor works before your program actually runs, during the compilation process. Here are some interesting things about the C preprocessor: 1) When you &#8230; <a title=\"Interesting Facts About Macros And Preprocessors In C\" class=\"read-more\" href=\"https:\/\/www.skillvertex.com\/blog\/interesting-facts-about-macros-and-preprocessors-in-c\/\" aria-label=\"More on Interesting Facts About Macros And Preprocessors In C\">Read more<\/a><\/p>\n","protected":false},"author":4,"featured_media":3292,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[27],"tags":[549],"class_list":["post-3291","post","type-post","status-publish","format-standard","has-post-thumbnail","hentry","category-c-programming","tag-interesting-facts-about-macros-and-preprocessors-in-c","generate-columns","tablet-grid-50","mobile-grid-100","grid-parent","grid-33"],"_links":{"self":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/3291"}],"collection":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/comments?post=3291"}],"version-history":[{"count":5,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/3291\/revisions"}],"predecessor-version":[{"id":7918,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/3291\/revisions\/7918"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/media\/3292"}],"wp:attachment":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/media?parent=3291"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/categories?post=3291"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/tags?post=3291"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}