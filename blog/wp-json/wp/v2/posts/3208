{"id":3208,"date":"2024-03-05T12:40:05","date_gmt":"2024-03-05T12:40:05","guid":{"rendered":"https:\/\/www.skillvertex.com\/blog\/?p=3208"},"modified":"2024-03-05T12:40:05","modified_gmt":"2024-03-05T12:40:05","slug":"dynamically-growing-array-in-c","status":"publish","type":"post","link":"https:\/\/www.skillvertex.com\/blog\/dynamically-growing-array-in-c\/","title":{"rendered":"Dynamically Growing Array In C"},"content":{"rendered":"\n<div class=\"wp-block-rank-math-toc-block\" id=\"rank-math-toc\" id=\"rank-math-toc\"><p>Table of Contents<\/p><nav><ul><li ><a href=\"#dynamically-growing-array-in-c\">Dynamically Growing Array In C<\/a><\/li><li ><a href=\"#basic-principle\">Basic Principle<\/a><\/li><li ><a href=\"#working\">Working<\/a><\/li><li ><a href=\"#c-program-for-dynamically-growing-array\">C Program for Dynamically Growing Array<\/a><\/li><li ><a href=\"#components-of-dynamically-growing-array\">Components of Dynamically Growing Array<\/a><ul><li ><a href=\"#1-dynamic-array\">1. dynamic_array<\/a><\/li><li ><a href=\"#2-array-init\">2. arrayInit()<\/a><\/li><li ><a href=\"#3-free-array\">3. freeArray()<\/a><\/li><\/ul><\/li><li ><a href=\"#basic-operations\">Basic Operations<\/a><ul><li ><a href=\"#1-insert-item\">1.\u00a0insertItem()<\/a><\/li><li ><a href=\"#2-get-item\">2. getItem()<\/a><\/li><li ><a href=\"#3-update-item\">3.\u00a0updateItem()<\/a><\/li><li ><a href=\"#4-print-item\">4. printItem()<\/a><\/li><li ><a href=\"#5-delete-item\">5. deleteItem()<\/a><\/li><\/ul><\/li><li ><a href=\"#faq-dynamically-growing-array-in-c\">FAQ- Dynamically Growing Array in C<\/a><\/li><\/ul><\/nav><\/div>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"dynamically-growing-array-in-c\">Dynamically Growing Array In C<\/h2>\n\n\n\n<p>A Dynamically Growing Array is a type of dynamic array that can expand in size to store data as required. In the C language, static arrays have fixed sizes known at compile time, which can lead to space issues. <\/p>\n\n\n\n<p>Programming languages like C++, Python, and Java have built-in data structures that manage size automatically. The goal is to create a dynamic array in C that can adjust its size dynamically to meet the program&#8217;s requirements, thus avoiding issues with wasted memory or running out of space.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"basic-principle\">Basic Principle<\/h2>\n\n\n\n<p>The fundamental principle of the Dynamically Growing Array is based on the dynamic memory allocation concept in C. This concept enables users to allocate memory during program execution and adjust the allocated size as needed.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"working\">Working<\/h2>\n\n\n\n<ol class=\"wp-block-list\">\n<li><strong>Start with a Small Initial Size<\/strong>: The newly created dynamic array begins with a small initial size to save memory.<\/li>\n\n\n\n<li><strong>Provide Standard Array Operations<\/strong>: Functions are available to perform typical array operations, like adding, accessing, or removing elements, just as you would with a regular array.<\/li>\n\n\n\n<li><strong>Double the Capacity When Needed<\/strong>: When the array runs out of space, its capacity is doubled by using the <code>realloc()<\/code> function to reallocate memory. Doubling the size is preferred over increasing it one by one because multiple <code>realloc()<\/code> calls can be costly and may impact the efficiency of insertion operations.<\/li>\n\n\n\n<li><strong>Amortized Constant Time Complexity<\/strong>: Doubling the array&#8217;s size has amortized constant time complexity for insertion operations, making it efficient in practice.<\/li>\n\n\n\n<li>**Clear Memory with <code>free()**: After the array is no longer needed, the memory is released using the<\/code>free()` function to prevent memory leaks.<\/li>\n<\/ol>\n\n\n\n<p>This approach ensures that the Dynamically Growing Array is both memory-efficient and time-efficient for various operations.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"c-program-for-dynamically-growing-array\">C Program for Dynamically Growing Array<\/h2>\n\n\n\n<pre class=\"wp-block-code\"><code>\n\n\/\/ C program to demonstrate the  \n\/\/ dynamically growing array \n#include &lt;stdio.h&gt; \n#include &lt;stdlib.h&gt; \n  \n#define INITIAL_SIZE 8 \n  \n\/\/ base structure \ntypedef struct { \n    size_t size; \n    size_t capacity; \n    int* array; \n}dynamic_array; \n  \n\/\/ function prototypes \n\/\/  array container functions \nvoid arrayInit(dynamic_array** arr_ptr); \nvoid freeArray(dynamic_array* container); \n  \n\/\/ Basic Operation functions \nvoid insertItem(dynamic_array* container, int item); \nvoid updateItem(dynamic_array* container, int i, int item); \nint getItem(dynamic_array* container, int i); \nvoid deleteItem(dynamic_array* container, int item); \nvoid printArray(dynamic_array* container); \n  \n\/\/ driver code \nint main() \n{ \n    dynamic_array* arr; \n    arrayInit(&amp;arr); \n      \n    for (int i = 0; i &lt; 6; i++) { \n        insertItem(arr, i + 11); \n    } \n    printArray(arr); \n    printf(\"%d\\n\", getItem(arr, 3)); \n    deleteItem(arr, 3); \n    printArray(arr); \n  \n    for (int i = 0; i &lt; 5; i++) { \n        insertItem(arr, i + 17); \n    } \n  \n    printArray(arr); \n  \n    freeArray(arr); \n    int var; \n    return 0; \n} \n\/\/------Function Definitions------ \n\/\/ Array initialization \nvoid arrayInit(dynamic_array** arr_ptr) \n{ \n    dynamic_array *container; \n    container = (dynamic_array*)malloc(sizeof(dynamic_array)); \n    if(!container) { \n        printf(\"Memory Allocation Failed\\n\"); \n        exit(0); \n    } \n  \n    container-&gt;size = 0; \n    container-&gt;capacity = INITIAL_SIZE; \n    container-&gt;array = (int *)malloc(INITIAL_SIZE * sizeof(int)); \n    if (!container-&gt;array){ \n        printf(\"Memory Allocation Failed\\n\"); \n        exit(0); \n    } \n  \n    *arr_ptr = container; \n} \n  \n\/\/  Insertion Operation \nvoid insertItem(dynamic_array* container, int item) \n{ \nif (container-&gt;size == container-&gt;capacity) { \n        int *temp = container-&gt;array; \n        container-&gt;capacity &lt;&lt;= 1; \n        container-&gt;array = realloc(container-&gt;array, container-&gt;capacity * sizeof(int)); \n        if(!container-&gt;array) { \n            printf(\"Out of Memory\\n\"); \n            container-&gt;array = temp; \n            return; \n        } \n    } \n    container-&gt;array&#91;container-&gt;size++] = item; \n} \n  \n\/\/ Retrieve Item at Particular Index \nint getItem(dynamic_array* container, int index) \n{ \n    if(index &gt;= container-&gt;size) { \n        printf(\"Index Out of Bounds\\n\"); \n        return -1; \n    } \n    return container-&gt;array&#91;index]; \n} \n  \n\/\/ Update Operation \nvoid updateItem(dynamic_array* container, int index, int item) \n{ \n    if (index &gt;= container-&gt;size) { \n        printf(\"Index Out of Bounds\\n\"); \n        return; \n    } \n    container-&gt;array&#91;index] = item; \n} \n  \n\/\/ Delete Item from Particular Index \nvoid deleteItem(dynamic_array* container, int index) \n{ \n    if(index &gt;= container-&gt;size) { \n        printf(\"Index Out of Bounds\\n\"); \n        return; \n    } \n  \n    for (int i = index; i &lt; container-&gt;size; i++) { \n        container-&gt;array&#91;i] = container-&gt;array&#91;i + 1]; \n    } \n    container-&gt;size--; \n} \n  \n\/\/ Array Traversal \nvoid printArray(dynamic_array* container) \n{ \n    printf(\"Array elements: \"); \n    for (int i = 0; i &lt; container-&gt;size; i++) { \n        printf(\"%d \", container-&gt;array&#91;i]); \n    } \n    printf(\"\\nSize: \"); \n    printf(\"%lu\", container-&gt;size); \n    printf(\"\\nCapacity: \"); \n    printf(\"%lu\\n\", container-&gt;capacity); \n} \n  \n\/\/ Freeing the memory allocated to the array \nvoid freeArray(dynamic_array* container) \n{ \n    free(container-&gt;array); \n    free(container); \n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>Array elements: 11 12 13 14 15 16 \nSize: 6\nCapacity: 8\n14\nArray elements: 11 12 13 15 16 \nSize: 5\nCapacity: 8\nArray elements: 11 12 13 15 16 17 18 19 20 21 \nSize: 10\nCapacity: 16<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"components-of-dynamically-growing-array\">Components of Dynamically Growing Array<\/h2>\n\n\n\n<ol class=\"wp-block-list\">\n<li><strong>dynamic_array<\/strong>: The core structure for the dynamic array.<\/li>\n\n\n\n<li><strong>arrayInit()<\/strong>: Function to set up and initialize the array.<\/li>\n\n\n\n<li><strong>deleteArr()<\/strong>: Function for freeing up memory when done with the array.<\/li>\n<\/ol>\n\n\n\n<h3 class=\"wp-block-heading\" id=\"1-dynamic-array\">1. dynamic_array<\/h3>\n\n\n\n<ol class=\"wp-block-list\">\n<li><strong>size<\/strong>: Keeps track of how much memory is being used.<\/li>\n\n\n\n<li><strong>capacity<\/strong>: Keeps track of the maximum capacity of the array.<\/li>\n\n\n\n<li><strong>array<\/strong>: A pointer to the actual storage location, typically an array of integers (int).<\/li>\n<\/ol>\n\n\n\n<p>Code<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>typedef struct {\n    size_t size;\n    size_t capacity;\n    int* array;\n} dynamic_array;<\/code><\/pre>\n\n\n\n<h3 class=\"wp-block-heading\" id=\"2-array-init\">2. arrayInit()<\/h3>\n\n\n\n<p>This function initializes the dynamic array with a default size of 8. It accepts the address of a double-pointer to the <code>dynamic_array<\/code> as an argument.<\/p>\n\n\n\n<p>Code:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>void arrayInit(dynamic_array** arr_ptr)\n{\n    dynamic_array *container;\n    container = (dynamic_array*)malloc(sizeof(dynamic_array));\n    if(!container) {\n        printf(\"Memory Allocation Failed\\n\");\n        exit(0);\n    }\n\n    container-&gt;size = 0;\n    container-&gt;capacity = INITIAL_SIZE;\n    container-&gt;array = (int *)malloc(INITIAL_SIZE * sizeof(int));\n    if (!container-&gt;array){\n        printf(\"Memory Allocation Failed\\n\");\n        exit(0);\n    }\n\n    *arr_ptr = container;\n}<\/code><\/pre>\n\n\n\n<h3 class=\"wp-block-heading\" id=\"3-free-array\">3. freeArray()<\/h3>\n\n\n\n<p>This function is responsible for releasing the memory allocated to the dynamically growing array. It should be called when you&#8217;re finished using the array to ensure proper memory management.<\/p>\n\n\n\n<p>Code:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>void freeArray(dynamic_array* container)\n{\n    free(container-&gt;array);\n    free(container);\n}<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"basic-operations\">Basic Operations<\/h2>\n\n\n\n<p>5 basic operations can provide basic operations of an array.<\/p>\n\n\n\n<ol class=\"wp-block-list\">\n<li><strong>insertItem():&nbsp;<\/strong>Used for  adding  an element at the end of the array<\/li>\n\n\n\n<li><strong>getItem():<\/strong>&nbsp;This operation is used to recover  the element at the given index<\/li>\n\n\n\n<li><strong>updateItem():&nbsp;<\/strong>Used to  update an element at that given index of the array<\/li>\n\n\n\n<li><strong>printItem():&nbsp;<\/strong>functions for printing all the elements of the array<\/li>\n\n\n\n<li><strong>deleteItem():&nbsp;<\/strong> Used to  delete an element of the array at the given index<\/li>\n<\/ol>\n\n\n\n<h3 class=\"wp-block-heading\" id=\"1-insert-item\">1.&nbsp;<strong>insertItem()<\/strong><\/h3>\n\n\n\n<p>The <code>insertItem()<\/code> function allows you to add elements to an array. When there&#8217;s available space, it inserts elements without changing the array&#8217;s size. However, when the array is full, it uses the <code>realloc()<\/code> function to double the array&#8217;s capacity and then perform the insertion. This strategy optimizes the efficiency of insertions by minimizing the need for frequent resizing.<\/p>\n\n\n\n<p>Code:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>void insertItem(dynamic_array* container, int item)\n{\n    if (container-&gt;size == container-&gt;capacity) {\n        int *temp = container-&gt;array;\n        container-&gt;capacity &lt;&lt;= 1;\n        container-&gt;array = realloc(container-&gt;array, container-&gt;capacity * sizeof(int));\n        if(!container-&gt;array) {\n            printf(\"Out of Memory\\n\");\n            container-&gt;array = temp;\n            return;\n        }\n    }\n    container-&gt;array&#91;container-&gt;size++] = item;\n}<\/code><\/pre>\n\n\n\n<h3 class=\"wp-block-heading\" id=\"2-get-item\">2. getItem()<\/h3>\n\n\n\n<p>This function returns the integer value located at a specified index. It requires two arguments: the container&#8217;s address and the index.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>int getItem(dynamic_array* container, int index)\n{\n    if(index &gt; container-&gt;size) {\n        printf(\"Index Out of Bounds\\n\");\n        return -1;\n    }\n    return container-&gt;array&#91;index];\n}<\/code><\/pre>\n\n\n\n<h3 class=\"wp-block-heading\" id=\"3-update-item\">3.&nbsp;<strong>updateItem()<\/strong><\/h3>\n\n\n\n<p>The <code>updateItem()<\/code> function allows you to update an element at a specific index in a container. It accepts three arguments: the container&#8217;s address, the index, and the new updated item.<\/p>\n\n\n\n<p>Code:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>void updateItem(dynamic_array* container, int index, int item)\n{\n    if (index &gt; container-&gt;size) {\n        printf(\"Index Out of Bounds\\n\");\n        return;\n    }\n    container-&gt;array&#91;index] = item;\n}<\/code><\/pre>\n\n\n\n<h3 class=\"wp-block-heading\" id=\"4-print-item\"><strong>4. printItem()<\/strong><\/h3>\n\n\n\n<p>This function will pass over the array and then print all elements. Despite of that, it will also print the current size and capacity of the array.<\/p>\n\n\n\n<p>Code:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>void printArray(dynamic_array* container)\n{\n    printf(\"Array elements: \");\n    for (int i = 0; i &lt; container-&gt;size; i++) {\n        printf(\"%d \", container-&gt;array&#91;i]);\n    }\n    printf(\"\\nSize: \");\n    printf(\"%ld\", container-&gt;size);\n    printf(\"\\nCapacity: \");\n    printf(\"%ld\\n\", container-&gt;capacity);\n}<\/code><\/pre>\n\n\n\n<h3 class=\"wp-block-heading\" id=\"5-delete-item\"><strong>5. deleteItem()<\/strong><\/h3>\n\n\n\n<p>This function will allow to delete of the delete operation using the remove element at the purticular index.<\/p>\n\n\n\n<p>Code:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>void deleteItem(dynamic_array* container, int index)\n{\n    if(index &gt; container-&gt;size) {\n        printf(\"Index Out of Bounds\\n\");\n        return;\n    }\n\n    for (int i = index; i &lt; container-&gt;size; i++) {\n        container-&gt;array&#91;i] = container-&gt;array&#91;i + 1];\n    }\n    container-&gt;size--;\n}<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"faq-dynamically-growing-array-in-c\">FAQ- Dynamically Growing Array in C<\/h2>\n\n\n<div id=\"rank-math-faq\" class=\"rank-math-block\">\n<div class=\"rank-math-list \">\n<div id=\"faq-question-1698904350236\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q1. How to dynamically grow an array in C?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. The &#8220;realloc&#8221; or &#8220;re-allocation&#8221; function in C is used to dynamically adjust the memory allocation of a previously allocated memory block. This function can be used to either create a new array or change the size of an existing array. Syntax- <code>ptr = realloc(ptr, newSize);<\/code><\/p>\n\n<\/div>\n<\/div>\n<div id=\"faq-question-1698904355362\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q2. Can we increase array size dynamically?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. We cannot increase the array size dynamically, instead, we can copy it into a new array. <\/p>\n\n<\/div>\n<\/div>\n<div id=\"faq-question-1698904360591\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q3. What is the meaning of a dynamic array?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. A dynamic array is like a flexible list that can grow or shrink as you add or remove elements. It&#8217;s available in modern programming languages and is more versatile than fixed-size arrays because it can change in size as needed, making it easy to work with varying amounts of data. <\/p>\n\n<\/div>\n<\/div>\n<\/div>\n<\/div>","protected":false},"excerpt":{"rendered":"<p>Dynamically Growing Array In C A Dynamically Growing Array is a type of dynamic array that can expand in size to store data as required. In the C language, static arrays have fixed sizes known at compile time, which can lead to space issues. Programming languages like C++, Python, and Java have built-in data structures &#8230; <a title=\"Dynamically Growing Array In C\" class=\"read-more\" href=\"https:\/\/www.skillvertex.com\/blog\/dynamically-growing-array-in-c\/\" aria-label=\"More on Dynamically Growing Array In C\">Read more<\/a><\/p>\n","protected":false},"author":4,"featured_media":3206,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[27],"tags":[529],"class_list":["post-3208","post","type-post","status-publish","format-standard","has-post-thumbnail","hentry","category-c-programming","tag-dynamically-growing-array-in-c","generate-columns","tablet-grid-50","mobile-grid-100","grid-parent","grid-33"],"_links":{"self":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/3208"}],"collection":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/comments?post=3208"}],"version-history":[{"count":8,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/3208\/revisions"}],"predecessor-version":[{"id":7910,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/3208\/revisions\/7910"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/media\/3206"}],"wp:attachment":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/media?parent=3208"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/categories?post=3208"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/tags?post=3208"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}