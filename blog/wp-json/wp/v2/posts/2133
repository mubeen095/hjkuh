{"id":2133,"date":"2024-05-10T07:11:49","date_gmt":"2024-05-10T07:11:49","guid":{"rendered":"https:\/\/www.skillvertex.com\/blog\/?p=2133"},"modified":"2024-05-10T07:11:49","modified_gmt":"2024-05-10T07:11:49","slug":"properties-of-array-in-c","status":"publish","type":"post","link":"https:\/\/www.skillvertex.com\/blog\/properties-of-array-in-c\/","title":{"rendered":"Properties of Array in C"},"content":{"rendered":"\n<div class=\"wp-block-rank-math-toc-block\" id=\"rank-math-toc\" id=\"rank-math-toc\"><p>Table of Contents<\/p><nav><ul><li ><a href=\"#properties-of-array-in-c\">Properties of Array in C<\/a><\/li><li ><a href=\"#c-array-properties\">C Array Properties<\/a><ul><li ><a href=\"#1-fixed-size-of-an-array\">1. Fixed Size of an Array<\/a><\/li><li ><a href=\"#2-homogeneous-collection\">2. Homogeneous Collection<\/a><\/li><li ><a href=\"#3-indexing-in-an-array\">3. Indexing in an Array<\/a><\/li><li ><a href=\"#4-dimensions-of-the-array\">4. Dimensions of the Array<\/a><\/li><li ><a href=\"#5-contiguous-storage\">5. Contiguous Storage<\/a><\/li><li ><a href=\"#6-random-access-to-the-elements\">6. Random Access to the Elements<\/a><\/li><li ><a href=\"#7-relationship-between-array-and-pointers\">7. Relationship between Array and Pointers<\/a><\/li><li ><a href=\"#8-bound-checking\">8. Bound Checking<\/a><\/li><li ><a href=\"#9-array-decay\">9. Array Decay<\/a><\/li><\/ul><\/li><li ><a href=\"#faq-properties-of-array-in-c\">FAQ- Properties of Array in C<\/a><\/li><\/ul><\/nav><\/div>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"properties-of-array-in-c\">Properties of Array in C<\/h2>\n\n\n\n<p>In C, an array is a fixed-size collection of elements stored in a continuous block of memory. Arrays are a fundamental data type in C, capable of storing elements of various data types like integers, characters, or even custom structures. They are widely used by programmers to address various challenges not only in C but also in other programming languages.<\/p>\n\n\n\n<p>The characteristics and behaviours of arrays can vary depending on the programming language. In this article, we will explore the specific properties and features of arrays in the C programming language.<\/p>\n\n\n\n<ol class=\"wp-block-list\">\n<li>Fixed Size Collection<\/li>\n\n\n\n<li>Homogeneous Elements<\/li>\n\n\n\n<li>Indexing in Array<\/li>\n\n\n\n<li>Dimensions of Array<\/li>\n\n\n\n<li>Contiguous Storage<\/li>\n\n\n\n<li>Random Access<\/li>\n\n\n\n<li>Array name relation with pointer<\/li>\n\n\n\n<li>Bound Checking<\/li>\n\n\n\n<li>Array Decay<\/li>\n<\/ol>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"c-array-properties\">C Array Properties<\/h2>\n\n\n\n<h3 class=\"wp-block-heading\" id=\"1-fixed-size-of-an-array\">1. Fixed Size of an Array<\/h3>\n\n\n\n<p>In C, the size of an array is set when it&#8217;s declared and cannot be changed during program execution. This size must be determined at compile-time and remains constant.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/\/ C Program to Illustrate the Fixed Size Properties of the\n\/\/ Array\n#include &lt;stdio.h&gt;\n \nint main()\n{\n \n    \/\/ creating a new array of size 5\n    int array&#91;5] = { 1, 2, 3, 4, 5 };\n \n    printf(\"Size of Array Before: %d\\n\",\n           sizeof(array) \/ sizeof(int));\n \n    \/\/ trying to increase the size of the array\n    array&#91;6];\n    \/\/ not checking the size\n    printf(\"Size of Array After: %d\",\n           sizeof(array) \/ sizeof(int));\n \n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>Size of Array Before: 5\nSize of Array After: 5<\/code><\/pre>\n\n\n\n<h3 class=\"wp-block-heading\" id=\"2-homogeneous-collection\">2. Homogeneous Collection<\/h3>\n\n\n\n<p>An array in C doesn&#8217;t have elements of different data types, instead they  are of the same type.<\/p>\n\n\n\n<p>Example<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\n\/\/ C program to Demonstrate the Homogeneous Property of the\n\/\/ C Array\n#include &lt;stdio.h&gt;\n \nint main()\n{\n \n    \/\/ declaring integer array\n    int arr&#91;3] = { 1, 2 };\n \n    \/\/ trying to store string in the third element\n    arr&#91;2] = \"skill vertex\";\n \n  \/\/ printing elements\n    printf(\"Array&#91;1]: %d\\n\", arr&#91;0]);\n    printf(\"Array&#91;2]: %d\\n\", arr&#91;1]);\n    printf(\"Array&#91;3]: %s\", arr&#91;2]);\n \n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>main.c: In function \u2018main\u2019:\nmain.c:12:16: warning: assignment to \u2018int\u2019 from \u2018char *\u2019 makes integer from pointer without a cast &#91;-Wint-conversion]\n   12 |         arr&#91;2] = \"skillvertex\";\n      |                ^\nmain.c:17:28: warning: format \u2018%s\u2019 expects argument of type \u2018char *\u2019, but argument 2 has type \u2018int\u2019 &#91;-Wformat=]\n   17 |         printf(\"Array&#91;3]: %s\", arr&#91;2]);\n      |                           ~^   ~~~~~~\n      |                            |      |\n      |                            char * int\n      |                           %d\nArray&#91;1]: 1\nArray&#91;2]: 2<\/code><\/pre>\n\n\n\n<h3 class=\"wp-block-heading\" id=\"3-indexing-in-an-array\">3. Indexing in an Array<\/h3>\n\n\n\n<p>In C, indexing of elements in an array starts with 0, not 1. This means that the first element in the array has an index of 0, and the index of the last element is equal to the size of the array minus 1. So, if you have an array of size <code>n<\/code>, the valid indices for that array range from 0 to <code>n - 1<\/code>.<\/p>\n\n\n\n<p>Example<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/\/ C Program to Illustrate Array Indexing in C\n#include &lt;stdio.h&gt;\n \nint main()\n{\n \n    \/\/ creating integer array with 2 elements\n    int arr&#91;2] = { 10, 20 };\n \n    \/\/ printing element at index 1\n    printf(\"Array&#91;1]: %d\\n\", arr&#91;1]);\n \n    \/\/ printing element at index 0\n    printf(\"Array&#91;0]: %d\", arr&#91;0]);\n   \n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>Array&#91;1]: 20\nArray&#91;0]: 10<\/code><\/pre>\n\n\n\n<p>&nbsp;In the above example, at index 1, the second element is present while at index 0, the first element is present.<\/p>\n\n\n\n<h3 class=\"wp-block-heading\" id=\"4-dimensions-of-the-array\">4. Dimensions of the Array<\/h3>\n\n\n\n<p>In C, arrays can come in various forms. They can be single-dimensional, like 1-D arrays, or multidimensional, like 2-D, 3-D arrays, and beyond. These multidimensional arrays can have any number of dimensions, allowing you to represent complex data structures.<\/p>\n\n\n\n<p>The number of elements in a multidimensional array is calculated by multiplying the size of all its dimensions. For example, in a 2-D array with dimensions <code>m<\/code> and <code>n<\/code>, the total number of elements is <code>m * n<\/code>. In a 3-D array with dimensions <code>x<\/code>, <code>y<\/code>, and <code>z<\/code>, the total number of elements is <code>x * y * z<\/code>, and so on for higher dimensions.<\/p>\n\n\n\n<p>This flexibility in array dimensions allows C programmers to work with a wide range of data structures and efficiently manage multi-dimensional data.<\/p>\n\n\n\n<p>Example<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\n\/\/ C Program to create multidimensional array\n#include &lt;stdio.h&gt;\n \nint main()\n{\n \n    \/\/ creating 2d array\n    int arr2d&#91;2]&#91;2] = { 1, 2, 3, 4 };\n \n    \/\/ creating 3d array\n    int arr3d&#91;2]&#91;2]&#91;2] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n \n    printf(\"2D Array: \");\n    \/\/ printing 2d array\n    for (int i = 0; i &lt; 2; i++) {\n        for (int j = 0; j &lt; 2; j++) {\n            printf(\"%d \", arr2d&#91;i]&#91;j]);\n        }\n    }\n \n    printf(\"\\n3D Array: \");\n    \/\/ printing 3d array\n    for (int i = 0; i &lt; 2; i++) {\n        for (int j = 0; j &lt; 2; j++) {\n            for (int k = 0; k &lt; 2; k++) {\n                printf(\"%d \", arr3d&#91;i]&#91;j]&#91;k]);\n            }\n        }\n    }\n \n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output <\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>2D Array: 1 2 3 4 \n3D Array: 1 2 3 4 5 6 7 8 <\/code><\/pre>\n\n\n\n<h3 class=\"wp-block-heading\" id=\"5-contiguous-storage\">5. Contiguous Storage<\/h3>\n\n\n\n<p>In C, all the elements in an array are stored in contiguous or consecutive memory locations. This concept is easy to visualize in the case of a 1-D array, where elements are simply placed one after the other in memory. However, it&#8217;s important to note that even multidimensional arrays are stored contiguously in memory.<\/p>\n\n\n\n<p>The contiguous storage of multidimensional arrays is achieved by using row-major or column-major order. In row-major order, the elements of each row are stored one after another in memory, followed by the next row, and so on. In column-major order, the elements of each column are stored consecutively.<\/p>\n\n\n\n<p>You can verify this contiguous storage property of arrays in C by using pointers to access and iterate through the elements in memory. By incrementing a pointer to an array element, you can observe that it points to the next consecutive element in memory, confirming the contiguous storage arrangement.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\n\/\/ C Program to Verify the Contiguous Storage of Elements in\n\/\/ an Array\n#include &lt;stdio.h&gt;\n \nint main()\n{\n \n    \/\/ creating an array of 5 elements\n    int arr&#91;5] = { 1, 2, 3, 4, 5 };\n \n    \/\/ defining pointers to 2 consecutive elements\n    int* ptr1 = &amp;arr&#91;1];\n    int* ptr2 = &amp;arr&#91;2];\n \n    \/\/ printing the address of arr&#91;1] and arr&#91;2]\n    printf(\"Address of arr&#91;1] : %p\\n\", ptr1);\n    printf(\"Address of arr&#91;2] : %p\", ptr2);\n \n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\nAddress of arr&#91;1] : 0x7fffb8cc1ef4\nAddress of arr&#91;2] : 0x7fffb8cc1ef8<\/code><\/pre>\n\n\n\n<p>In the example you provided, where the difference between the addresses of <code>arr[1]<\/code> and <code>arr[2]<\/code> is 4 bytes, it indeed indicates that each element in the array occupies 4 bytes of memory. This aligns with the memory requirement for storing a single integer in many C implementations.<\/p>\n\n\n\n<p>So, in memory addresses ranging from <code>0x7ffebc02e054<\/code> to <code>0x7ffebc02e057<\/code>, the element <code>arr[1]<\/code> is stored, and in the subsequent 4 bytes of memory (<code>0x7ffebc02e058<\/code> to <code>0x7ffebc02e05B<\/code>), the element <code>arr[2]<\/code> is stored. This pattern continues for all the elements in the array, with each element occupying 4 bytes of memory, assuming it&#8217;s an integer array.<\/p>\n\n\n\n<p>This alignment and contiguous storage of elements in memory are crucial for efficient array access and manipulation in C.<\/p>\n\n\n\n<h3 class=\"wp-block-heading\" id=\"6-random-access-to-the-elements\">6. Random Access to the Elements<\/h3>\n\n\n\n<p>One of the defining and powerful properties of an array in C is the ability to access any element ra                                                                                                                         ndomly using its index. This capability is a direct consequence of contiguous storage, where all elements are stored consecutively in memory.<\/p>\n\n\n\n<p>The compiler can determine the address of an element at a given index by utilizing the address of the first element and the index number. This calculation allows for efficient and direct access to any array element without needing to traverse through other elements. This random access property is fundamental for various algorithms and data structures that rely on quick and direct element retrieval.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>Address of ith = Address of 1st Element + (Index * Size of Each Element)\n<\/code><\/pre>\n\n\n\n<p>Example<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/\/ C Program to check the random access property of the\n\/\/ array\n#include &lt;stdio.h&gt;\n \nint main()\n{\n \n    \/\/ creating an array of 5 elements\n    int arr&#91;5] = { 1, 2, 3, 4, 5 };\n \n    \/\/ address of first element\n    int* ptr = &amp;arr&#91;0];\n \n    \/\/ printing arr&#91;3]\n    printf(\"Array&#91;3]: %d\\n\", arr&#91;3]);\n \n    \/\/ printing element at index 3 using ptr\n    printf(\"Array&#91;3] using pointer to first element = %d\",\n           *(ptr + 3));\n \n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>Array&#91;3]: 4\nArray&#91;3] using pointer to first element = 4<\/code><\/pre>\n\n\n\n<h3 class=\"wp-block-heading\" id=\"7-relationship-between-array-and-pointers\">7. Relationship between Array and Pointers<\/h3>\n\n\n\n<p>Arrays in C are closely related to pointers, and it&#8217;s true that many operations that can be performed on an array can also be accomplished using pointers. The name of an array is, in fact, a pointer to its first element. This relationship allows you to use pointer arithmetic to navigate and manipulate array elements.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/\/ C Program to Illustrate the Relationship Between Array\n\/\/ and Pointers\n#include &lt;stdio.h&gt;\n \nint main()\n{\n \n    \/\/ creating an array with 3 elements\n    int arr&#91;3] = { 1, 2, 3 };\n \n    int* ptr = &amp;arr&#91;0];\n \n    \/\/ Pointer to first element\n    printf(\"Pointer to First Element: %p\\n\", ptr);\n \n    \/\/ Array name as pointer\n    printf(\"Arran Name: %p\", arr);\n \n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>Pointer to First Element: 0x7ffec5059660\nArran Name: 0x7ffec5059660<\/code><\/pre>\n\n\n\n<h3 class=\"wp-block-heading\" id=\"8-bound-checking\">8. Bound Checking<\/h3>\n\n\n\n<p>In C, bound checking, which involves verifying whether the element being accessed falls within the declared range of the array, is not automatically performed by the language itself. This means that C allows you to access elements outside the specified range of the array without raising any runtime errors or exceptions.<\/p>\n\n\n\n<p>While this flexibility can be useful in certain situations, it also comes with risks. Accessing elements outside the bounds of an array can lead to unexpected behavior and errors in your program, including memory corruption and security vulnerabilities. It&#8217;s the responsibility of the C programmer to ensure that array bounds are not violated and to perform manual bound checking when necessary to prevent these issues.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/\/ C Program to Illustrate the Out of Bound access in arrays\n#include &lt;stdio.h&gt;\n \nint main()\n{\n \n    \/\/ creating new array with 3 elements\n    int arr&#91;3] = { 1, 2, 3 };\n \n    \/\/ trying to access out of bound element\n    printf(\"Some Garbage Value: %d\", arr&#91;5]);\n \n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>Some Garbage Value: 0\n<\/code><\/pre>\n\n\n\n<h3 class=\"wp-block-heading\" id=\"9-array-decay\">9. Array Decay<\/h3>\n\n\n\n<p>Array decay is the phenomenon where an array loses its dimension and turns into a pointer under certain circumstances. One common situation where array decay occurs is when an array is passed as an argument to a function. When an array decays into a pointer, you can no longer determine its size using the <code>sizeof()<\/code> operator because the size information is lost.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>\/\/ C Program to Demonstrate the Array Decay\n#include &lt;stdio.h&gt;\n \n\/\/ function\nvoid func(int* arr)\n{\n    printf(\"Sizeof Value in Function: %d\", sizeof(arr));\n}\n \nint main()\n{\n \n    \/\/ creating array with 3 elements\n    char arr&#91;3];\n \n    printf(\"Sizeof Value in Main: %d\\n\", sizeof(arr));\n \n    \/\/ passing array\n    func(arr);\n \n    return 0;\n}<\/code><\/pre>\n\n\n\n<p>Output<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>Sizeof Value in Main: 3\nSizeof Value in Function: 8<\/code><\/pre>\n\n\n\n<p>The size of the array in the main() is 3 bytes which will be theb actual size of the array but when we check the size of the array in func(), the size comes out to be 8 bytes .So,  instead of being the size of the array, it is the size of the pointer to the first element of the array.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"faq-properties-of-array-in-c\">FAQ- Properties of Array in C<\/h2>\n\n\n<div id=\"rank-math-faq\" class=\"rank-math-block\">\n<div class=\"rank-math-list \">\n<div id=\"faq-question-1695721705042\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q1. What is array and its types in C?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. Arrays store multiple values in a single variable. To create an array, specify the data type (e.g., int) and give it a name followed by square brackets [].<\/p>\n\n<\/div>\n<\/div>\n<div id=\"faq-question-1695721716575\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q2. What are types of arrays?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. Arrays are categorized into two types: single-dimensional and multi-dimensional. A single-dimensional array represents linear data, while a two-dimensional array represents a matrix. Multidimensional arrays have multiple dimensions.<\/p>\n\n<\/div>\n<\/div>\n<div id=\"faq-question-1695721723230\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q3. What is the syntax of array?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. Arrays are defined using square brackets with the size specified:<br \/>1D Arrays: <code>int arr[n];<\/code><br \/>2D Arrays: <code>int arr[m][n];<\/code><\/p>\n\n<\/div>\n<\/div>\n<\/div>\n<\/div>","protected":false},"excerpt":{"rendered":"<p>Properties of Array in C In C, an array is a fixed-size collection of elements stored in a continuous block of memory. Arrays are a fundamental data type in C, capable of storing elements of various data types like integers, characters, or even custom structures. They are widely used by programmers to address various challenges &#8230; <a title=\"Properties of Array in C\" class=\"read-more\" href=\"https:\/\/www.skillvertex.com\/blog\/properties-of-array-in-c\/\" aria-label=\"More on Properties of Array in C\">Read more<\/a><\/p>\n","protected":false},"author":4,"featured_media":5316,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[27],"tags":[376],"class_list":["post-2133","post","type-post","status-publish","format-standard","has-post-thumbnail","hentry","category-c-programming","tag-properties-of-array-in-c","generate-columns","tablet-grid-50","mobile-grid-100","grid-parent","grid-33"],"_links":{"self":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/2133"}],"collection":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/comments?post=2133"}],"version-history":[{"count":12,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/2133\/revisions"}],"predecessor-version":[{"id":10629,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/2133\/revisions\/10629"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/media\/5316"}],"wp:attachment":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/media?parent=2133"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/categories?post=2133"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/tags?post=2133"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}