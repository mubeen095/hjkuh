{"id":3331,"date":"2024-03-05T12:55:53","date_gmt":"2024-03-05T12:55:53","guid":{"rendered":"https:\/\/www.skillvertex.com\/blog\/?p=3331"},"modified":"2024-03-05T12:55:53","modified_gmt":"2024-03-05T12:55:53","slug":"branch-prediction-macros-in-gcc","status":"publish","type":"post","link":"https:\/\/www.skillvertex.com\/blog\/branch-prediction-macros-in-gcc\/","title":{"rendered":"Branch Prediction Macros In GCC"},"content":{"rendered":"\n<div class=\"wp-block-rank-math-toc-block\" id=\"rank-math-toc\" id=\"rank-math-toc\"><p>Table of Contents<\/p><nav><ul><li ><a href=\"#branch-prediction-macros-in-gcc\">Branch Prediction Macros In GCC<\/a><\/li><li ><a href=\"#faq-branch-prediction-macros-in-gcc\">FAQ- Branch Prediction Macros In GCC<\/a><\/li><\/ul><\/nav><\/div>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"branch-prediction-macros-in-gcc\">Branch Prediction Macros In GCC<\/h2>\n\n\n\n<p>One commonly used optimization technique in the Linux kernel is &#8220;__builtin_expect.&#8221; When dealing with conditional code, such as if-else statements, there is often prior knowledge about which branch is more likely to be true and which is less likely. When the compiler is aware of this information, it can generate highly optimized code to improve performance. This technique is particularly valuable for enhancing the efficiency of code execution.<\/p>\n\n\n\n<p>Refer the macro definition of \u201clikely()\u201d and \u201cunlikely()\u201d macros from Linux kernel code \u201chttp:\/\/lxr.linux.no\/linux+v3.6.5\/include\/linux\/compiler.h\u201d .<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>Let us see macro definition of \u201clikely()\u201d and \u201cunlikely()\u201d macros from linux kernel code \u201chttp:\/\/lxr.linux.no\/linux+v3.6.5\/include\/linux\/compiler.h\u201d &#91;line no 146 and 147].\n\n<\/code><\/pre>\n\n\n\n<p>We are marking branches in the example given below:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>const char *home_dir ; \n  \nhome_dir = getenv(\"HOME\"); \nif (likely(home_dir))  \n    printf(\"home directory: %s\\n\", home_dir); \nelse\n    perror(\"getenv\");<\/code><\/pre>\n\n\n\n<p>In the example above, we&#8217;ve used the &#8220;likely()&#8221; macro to indicate that the &#8220;if&#8221; condition is more likely to be true. This allows the compiler to optimize the code by placing the true branch immediately after the branch instruction and the false branch within the branch instruction. This can result in significant performance improvements. However, it&#8217;s essential not to use &#8220;likely()&#8221; and &#8220;unlikely()&#8221; macros blindly. If the prediction is correct, there is no penalty in terms of jump instructions, but if the prediction is wrong, it can lead to a performance hit as the processor needs to flush its pipeline, which is worse than having no prediction.<\/p>\n\n\n\n<p>Memory access is one of the slowest CPU operations compared to other operations. To address this limitation, CPUs use CPU caches, such as L1-cache and L2-cache, to store a portion of memory directly within the CPU. Accessing cache memory is much faster than accessing other types of memory. However, cache memory has a limited size, so the CPU has to make educated guesses about which memory will be needed in the near future and load that memory into the CPU cache. The &#8220;likely()&#8221; and &#8220;unlikely()&#8221; macros serve as hints to the CPU to help it load the appropriate memory into the cache, optimizing memory access and improving overall performance.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\" id=\"faq-branch-prediction-macros-in-gcc\">FAQ- Branch Prediction Macros In GCC<\/h2>\n\n\n<div id=\"rank-math-faq\" class=\"rank-math-block\">\n<div class=\"rank-math-list \">\n<div id=\"faq-question-1699444437395\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q1. What is the use of unlikely in C?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. Using the &#8220;unlikely&#8221; macro guides the compiler to optimize by removing instructions from the likely code path. In the comparison mentioned, the compiler eliminates the instruction &#8220;xor eax, eax&#8221; from the likely path. This optimization streamlines execution, enhancing performance, particularly when the less likely code path is taken.<\/p>\n\n<\/div>\n<\/div>\n<div id=\"faq-question-1699444448604\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q2.How to define macro in gcc command line?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. When defining a function-like macro on the command line, enclose the argument list in parentheses before the equals sign. To ensure proper interpretation by shells like <code>sh<\/code> and <code>csh<\/code>, quote the entire macro definition in the format <code>-D'name (args...) = definition'<\/code>.<\/p>\n\n<\/div>\n<\/div>\n<div id=\"faq-question-1699444460510\" class=\"rank-math-list-item\">\n<h4 class=\"rank-math-question \">Q3. What is branch prediction C++?<\/h4>\n<div class=\"rank-math-answer \">\n\n<p>Ans. Branch prediction is a technique used to predict whether a conditional jump will be taken or not. On the other hand, branch target prediction aims to predict the target of a jump, whether conditional or unconditional, before it is determined through the instruction&#8217;s decoding and execution.<\/p>\n\n<\/div>\n<\/div>\n<\/div>\n<\/div>","protected":false},"excerpt":{"rendered":"<p>Branch Prediction Macros In GCC One commonly used optimization technique in the Linux kernel is &#8220;__builtin_expect.&#8221; When dealing with conditional code, such as if-else statements, there is often prior knowledge about which branch is more likely to be true and which is less likely. When the compiler is aware of this information, it can generate &#8230; <a title=\"Branch Prediction Macros In GCC\" class=\"read-more\" href=\"https:\/\/www.skillvertex.com\/blog\/branch-prediction-macros-in-gcc\/\" aria-label=\"More on Branch Prediction Macros In GCC\">Read more<\/a><\/p>\n","protected":false},"author":4,"featured_media":3333,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[27],"tags":[558],"class_list":["post-3331","post","type-post","status-publish","format-standard","has-post-thumbnail","hentry","category-c-programming","tag-branch-prediction-macros-in-gcc","generate-columns","tablet-grid-50","mobile-grid-100","grid-parent","grid-33"],"_links":{"self":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/3331"}],"collection":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/comments?post=3331"}],"version-history":[{"count":5,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/3331\/revisions"}],"predecessor-version":[{"id":7926,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/posts\/3331\/revisions\/7926"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/media\/3333"}],"wp:attachment":[{"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/media?parent=3331"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/categories?post=3331"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.skillvertex.com\/blog\/wp-json\/wp\/v2\/tags?post=3331"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}